{
  "version": 3,
  "sources": ["../node_modules/events/events.js", "../src/subscription.ts", "../src/codes.ts", "../src/types.ts", "../src/utils.ts", "../src/transport_sockjs.ts", "../src/transport_websocket.ts", "../src/transport_http_stream.ts", "../src/transport_sse.ts", "../src/transport_webtransport.ts", "../src/json.ts", "../src/centrifuge.ts", "../src/browser.ts"],
  "sourcesContent": ["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n", "import EventEmitter from 'events';\nimport { Centrifuge } from './centrifuge';\nimport { errorCodes, unsubscribedCodes, subscribingCodes, connectingCodes } from './codes';\nimport {\n  HistoryOptions, HistoryResult, PresenceResult, PresenceStatsResult,\n  PublishResult, State, SubscriptionEvents, SubscriptionOptions,\n  SubscriptionState, SubscriptionTokenContext, TypedEventEmitter\n} from './types';\nimport { ttlMilliseconds, backoff } from './utils';\n\n/** Subscription to a channel */\nexport class Subscription extends (EventEmitter as new () => TypedEventEmitter<SubscriptionEvents>) {\n  channel: string;\n  state: SubscriptionState;\n\n  private _centrifuge: Centrifuge;\n  private _promises: Record<number, any>;\n  private _resubscribeTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _refreshTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _getToken: null | ((ctx: SubscriptionTokenContext) => Promise<string>);\n  private _minResubscribeDelay: number;\n  private _maxResubscribeDelay: number;\n  private _recover: boolean;\n  private _offset: number | null;\n  private _epoch: string | null;\n  private _resubscribeAttempts: number;\n  private _promiseId: number;\n\n  private _token: string | null;\n  private _data: any | null;\n  private _recoverable: boolean;\n  private _positioned: boolean;\n  private _joinLeave: boolean;\n  // @ts-ignore \u2013 this is used by a client in centrifuge.ts.\n  private _inflight: boolean;\n\n  /** Subscription constructor should not be used directly, create subscriptions using Client method. */\n  constructor(centrifuge: Centrifuge, channel: string, options?: Partial<SubscriptionOptions>) {\n    super();\n    this.channel = channel;\n    this.state = SubscriptionState.Unsubscribed;\n    this._centrifuge = centrifuge;\n    this._token = null;\n    this._getToken = null;\n    this._data = null;\n    this._recover = false;\n    this._offset = null;\n    this._epoch = null;\n    this._recoverable = false;\n    this._positioned = false;\n    this._joinLeave = false;\n    this._minResubscribeDelay = 500;\n    this._maxResubscribeDelay = 20000;\n    this._resubscribeTimeout = null;\n    this._resubscribeAttempts = 0;\n    this._promises = {};\n    this._promiseId = 0;\n    this._inflight = false;\n    this._refreshTimeout = null;\n    this._setOptions(options);\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    if (this._centrifuge._debugEnabled) {\n      this.on('state', (ctx) => {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        this._centrifuge._debug('subscription state', channel, ctx.oldState, '->', ctx.newState);\n      });\n      this.on('error', (ctx) => {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        this._centrifuge._debug('subscription error', channel, ctx);\n      });\n    } else {\n      // Avoid unhandled exception in EventEmitter for non-set error handler.\n      this.on('error', function () { Function.prototype(); });\n    }\n  }\n\n  /** ready returns a Promise which resolves upon subscription goes to Subscribed \n   * state and rejects in case of subscription goes to Unsubscribed state. \n   * Optional timeout can be passed.*/\n  ready(timeout?: number): Promise<void> {\n    if (this.state === SubscriptionState.Unsubscribed) {\n      return Promise.reject({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n    }\n    if (this.state === SubscriptionState.Subscribed) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const ctx: any = {\n        resolve: res,\n        reject: rej\n      };\n      if (timeout) {\n        ctx.timeout = setTimeout(function () {\n          rej({ code: errorCodes.timeout, message: 'timeout' });\n        }, timeout);\n      }\n      this._promises[this._nextPromiseId()] = ctx;\n    });\n  }\n\n  /** subscribe to a channel.*/\n  subscribe() {\n    if (this._isSubscribed()) {\n      return;\n    }\n    this._resubscribeAttempts = 0;\n    this._setSubscribing(subscribingCodes.subscribeCalled, 'subscribe called');\n  }\n\n  /** unsubscribe from a channel, keeping position state.*/\n  unsubscribe() {\n    this._setUnsubscribed(unsubscribedCodes.unsubscribeCalled, 'unsubscribe called', true);\n  }\n\n  /** publish data to a channel.*/\n  publish(data: any): Promise<PublishResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.publish(self.channel, data);\n    });\n  }\n\n  /** get online presence for a channel.*/\n  presence(): Promise<PresenceResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presence(self.channel);\n    });\n  }\n\n  /** presence stats for a channel (num clients and unique users).*/\n  presenceStats(): Promise<PresenceStatsResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presenceStats(self.channel);\n    });\n  }\n\n  /** history for a channel. By default it does not return publications (only current\n   *  StreamPosition data) \u2013 provide an explicit limit > 0 to load publications.*/\n  history(opts: HistoryOptions): Promise<HistoryResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.history(self.channel, opts);\n    });\n  }\n\n  private _methodCall(): any {\n    if (this._isSubscribed()) {\n      return Promise.resolve();\n    }\n    if (this._isUnsubscribed()) {\n      return Promise.reject({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n    }\n    return new Promise((res, rej) => {\n      const timeout = setTimeout(function () {\n        rej({ code: errorCodes.timeout, message: 'timeout' });\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      }, this._centrifuge._config.timeout);\n      this._promises[this._nextPromiseId()] = {\n        timeout: timeout,\n        resolve: res,\n        reject: rej\n      };\n    });\n  }\n\n  private _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  private _needRecover() {\n    return this._recover === true;\n  }\n\n  private _isUnsubscribed() {\n    return this.state === SubscriptionState.Unsubscribed;\n  }\n\n  private _isSubscribing() {\n    return this.state === SubscriptionState.Subscribing;\n  }\n\n  private _isSubscribed() {\n    return this.state === SubscriptionState.Subscribed;\n  }\n\n  private _setState(newState: SubscriptionState) {\n    if (this.state !== newState) {\n      const oldState = this.state;\n      this.state = newState;\n      this.emit('state', { newState, oldState, channel: this.channel });\n      return true;\n    }\n    return false;\n  }\n\n  private _usesToken() {\n    return this._token !== null || this._getToken !== null;\n  }\n\n  private _clearSubscribingState() {\n    this._resubscribeAttempts = 0;\n    this._clearResubscribeTimeout();\n  }\n\n  private _clearSubscribedState() {\n    this._clearRefreshTimeout();\n  }\n\n  private _setSubscribed(result: any) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    this._clearSubscribingState();\n\n    if (result.recoverable) {\n      this._recover = true;\n      this._offset = result.offset || 0;\n      this._epoch = result.epoch || '';\n    }\n\n    this._setState(SubscriptionState.Subscribed);\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const ctx = this._centrifuge._getSubscribeContext(this.channel, result);\n    this.emit('subscribed', ctx);\n    this._resolvePromises();\n\n    const pubs = result.publications;\n    if (pubs && pubs.length > 0) {\n      for (const i in pubs) {\n        if (!pubs.hasOwnProperty(i)) {\n          continue;\n        }\n        this._handlePublication(pubs[i]);\n      }\n    }\n\n    if (result.expires === true) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _setSubscribing(code: number, reason: string) {\n    if (this._isSubscribing()) {\n      return;\n    }\n    if (this._isSubscribed()) {\n      this._clearSubscribedState();\n    }\n    if (this._setState(SubscriptionState.Subscribing)) {\n      this.emit('subscribing', { channel: this.channel, code: code, reason: reason });\n    }\n    this._subscribe(false, false);\n  }\n\n  private _subscribe(optimistic: boolean, skipSending: boolean): any {\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    this._centrifuge._debug('subscribing on', this.channel);\n\n    if (this._centrifuge.state !== State.Connected && !optimistic) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      this._centrifuge._debug('delay subscribe on', this.channel, 'till connected');\n      // subscribe will be called later automatically.\n      return null;\n    }\n\n    if (this._usesToken()) {\n      // token channel, need to get token before sending subscribe.\n      if (this._token) {\n        return this._sendSubscribe(this._token, skipSending);\n      } else {\n        if (optimistic) {\n          return null;\n        }\n        const self = this;\n        this._getSubscriptionToken().then(function (token) {\n          if (!self._isSubscribing()) {\n            return;\n          }\n          if (!token) {\n            self._failUnauthorized();\n            return;\n          }\n          self._token = token;\n          self._sendSubscribe(token, false);\n        }).catch(function (e) {\n          if (!self._isSubscribing()) {\n            return;\n          }\n          self.emit('error', {\n            type: 'subscribeToken',\n            channel: self.channel,\n            error: {\n              code: errorCodes.subscriptionSubscribeToken,\n              message: e !== undefined ? e.toString() : ''\n            }\n          });\n          self._scheduleResubscribe();\n        });\n        return null;\n      }\n    } else {\n      return this._sendSubscribe('', skipSending);\n    }\n  }\n\n  private _sendSubscribe(token: string, skipSending: boolean): any {\n    const channel = this.channel;\n\n    const req: any = {\n      channel: channel\n    };\n\n    if (token) {\n      req.token = token;\n    }\n\n    if (this._data) {\n      req.data = this._data;\n    }\n\n    if (this._positioned) {\n      req.positioned = true;\n    }\n\n    if (this._recoverable) {\n      req.recoverable = true;\n    }\n\n    if (this._joinLeave) {\n      req.join_leave = true;\n    }\n\n    if (this._needRecover()) {\n      req.recover = true;\n      const offset = this._getOffset();\n      if (offset) {\n        req.offset = offset;\n      }\n      const epoch = this._getEpoch();\n      if (epoch) {\n        req.epoch = epoch;\n      }\n    }\n\n    const cmd = { subscribe: req };\n\n    this._inflight = true;\n\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    this._centrifuge._call(cmd, skipSending).then(resolveCtx => {\n      this._inflight = false;\n      // @ts-ignore - improve later.\n      const result = resolveCtx.reply.subscribe;\n      this._handleSubscribeResponse(\n        result\n      );\n      // @ts-ignore - improve later.\n      if (resolveCtx.next) {\n        // @ts-ignore - improve later.\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      this._inflight = false;\n      this._handleSubscribeError(rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n    return cmd;\n  }\n\n  private _handleSubscribeError(error) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    if (error.code === errorCodes.timeout) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      this._centrifuge._disconnect(connectingCodes.subscribeTimeout, 'subscribe timeout', true);\n      return;\n    }\n    this._subscribeError(error);\n  }\n\n  private _handleSubscribeResponse(result) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    this._setSubscribed(result);\n  }\n\n  private _setUnsubscribed(code, reason, sendUnsubscribe) {\n    if (this._isUnsubscribed()) {\n      return;\n    }\n    if (this._isSubscribed()) {\n      if (sendUnsubscribe) {\n        // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n        this._centrifuge._unsubscribe(this);\n      }\n      this._clearSubscribedState();\n    }\n    if (this._isSubscribing()) {\n      this._clearSubscribingState();\n    }\n    if (this._setState(SubscriptionState.Unsubscribed)) {\n      this.emit('unsubscribed', { channel: this.channel, code: code, reason: reason });\n    }\n    this._rejectPromises({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n  }\n\n  private _handlePublication(pub: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const ctx = this._centrifuge._getPublicationContext(this.channel, pub);\n    this.emit('publication', ctx);\n    if (pub.offset) {\n      this._offset = pub.offset;\n    }\n  }\n\n  protected _handleJoin(join: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const info = this._centrifuge._getJoinLeaveContext(join.info)\n    this.emit('join', { channel: this.channel, info: info });\n  }\n\n  protected _handleLeave(leave: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const info = this._centrifuge._getJoinLeaveContext(leave.info)\n    this.emit('leave', { channel: this.channel, info: info });\n  }\n\n  private _resolvePromises() {\n    for (const id in this._promises) {\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  }\n\n  private _rejectPromises(err: any) {\n    for (const id in this._promises) {\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  }\n\n  private _scheduleResubscribe() {\n    const self = this;\n    const delay = this._getResubscribeDelay();\n    this._resubscribeTimeout = setTimeout(function () {\n      if (self._isSubscribing()) {\n        self._subscribe(false, false);\n      }\n    }, delay);\n  }\n\n  private _subscribeError(err: any) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    if (err.code < 100 || err.code === 109 || err.temporary === true) {\n      if (err.code === 109) { // Token expired error.\n        this._token = null;\n      }\n      const errContext = {\n        channel: this.channel,\n        type: 'subscribe',\n        error: err\n      };\n      if (this._centrifuge.state === State.Connected) {\n        this.emit('error', errContext);\n      }\n      this._scheduleResubscribe();\n    } else {\n      this._setUnsubscribed(err.code, err.message, false);\n    }\n  }\n\n  private _getResubscribeDelay() {\n    const delay = backoff(this._resubscribeAttempts, this._minResubscribeDelay, this._maxResubscribeDelay);\n    this._resubscribeAttempts++;\n    return delay;\n  }\n\n  private _setOptions(options: Partial<SubscriptionOptions> | undefined) {\n    if (!options) {\n      return;\n    }\n    if (options.since) {\n      this._offset = options.since.offset;\n      this._epoch = options.since.epoch;\n      this._recover = true;\n    }\n    if (options.data) {\n      this._data = options.data;\n    }\n    if (options.minResubscribeDelay !== undefined) {\n      this._minResubscribeDelay = options.minResubscribeDelay;\n    }\n    if (options.maxResubscribeDelay !== undefined) {\n      this._maxResubscribeDelay = options.maxResubscribeDelay;\n    }\n    if (options.token) {\n      this._token = options.token;\n    }\n    if (options.getToken) {\n      this._getToken = options.getToken;\n    }\n    if (options.positioned === true) {\n      this._positioned = true;\n    }\n    if (options.recoverable === true) {\n      this._recoverable = true;\n    }\n    if (options.joinLeave === true) {\n      this._joinLeave = true;\n    }\n  }\n\n  private _getOffset() {\n    const offset = this._offset;\n    if (offset !== null) {\n      return offset;\n    }\n    return 0;\n  }\n\n  private _getEpoch() {\n    const epoch = this._epoch;\n    if (epoch !== null) {\n      return epoch;\n    }\n    return '';\n  }\n\n  private _clearRefreshTimeout() {\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n  }\n\n  private _clearResubscribeTimeout() {\n    if (this._resubscribeTimeout !== null) {\n      clearTimeout(this._resubscribeTimeout);\n      this._resubscribeTimeout = null;\n    }\n  }\n\n  private _getSubscriptionToken() {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    this._centrifuge._debug('get subscription token for channel', this.channel);\n    const ctx = {\n      channel: this.channel\n    };\n    const getToken = this._getToken;\n    if (getToken === null) {\n      throw new Error('provide a function to get channel subscription token');\n    }\n    return getToken(ctx);\n  }\n\n  private _refresh() {\n    this._clearRefreshTimeout();\n    const self = this;\n    this._getSubscriptionToken().then(function (token) {\n      if (!self._isSubscribed()) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      const req = {\n        channel: self.channel,\n        token: token\n      };\n      const msg = {\n        'sub_refresh': req\n      };\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      self._centrifuge._call(msg).then(resolveCtx => {\n        // @ts-ignore - improve later.\n        const result = resolveCtx.reply.sub_refresh;\n        self._refreshResponse(result);\n        // @ts-ignore - improve later.\n        if (resolveCtx.next) {\n          // @ts-ignore - improve later.\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        self._refreshError(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }).catch(function (e) {\n      self.emit('error', {\n        type: 'refreshToken',\n        channel: self.channel,\n        error: {\n          code: errorCodes.subscriptionRefreshToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n    });\n  }\n\n  private _refreshResponse(result: any) {\n    if (!this._isSubscribed()) {\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    this._centrifuge._debug('subscription token refreshed, channel', this.channel);\n    this._clearRefreshTimeout();\n    if (result.expires === true) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _refreshError(err: any) {\n    if (!this._isSubscribed()) {\n      return;\n    }\n    if (err.code < 100 || err.temporary === true) {\n      this.emit('error', {\n        type: 'refresh',\n        channel: this.channel,\n        error: err\n      });\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n    } else {\n      this._setUnsubscribed(err.code, err.message, true);\n    }\n  }\n\n  private _getRefreshRetryDelay() {\n    return backoff(0, 10000, 20000);\n  }\n\n  private _failUnauthorized() {\n    this._setUnsubscribed(unsubscribedCodes.unauthorized, 'unauthorized', true);\n  }\n}\n", "export const errorCodes = {\n  timeout: 1,\n  transportClosed: 2,\n  clientDisconnected: 3,\n  clientClosed: 4,\n  clientConnectToken: 5,\n  clientRefreshToken: 6,\n  subscriptionUnsubscribed: 7,\n  subscriptionSubscribeToken: 8,\n  subscriptionRefreshToken: 9,\n  transportWriteError: 10,\n  connectionClosed: 11\n};\n\nexport const connectingCodes = {\n  connectCalled: 0,\n  transportClosed: 1,\n  noPing: 2,\n  subscribeTimeout: 3,\n  unsubscribeError: 4\n};\n\nexport const disconnectedCodes = {\n  disconnectCalled: 0,\n  unauthorized: 1,\n  badProtocol: 2,\n  messageSizeLimit: 3\n};\n\nexport const subscribingCodes = {\n  subscribeCalled: 0,\n  transportClosed: 1\n};\n\nexport const unsubscribedCodes = {\n  unsubscribeCalled: 0,\n  unauthorized: 1,\n  clientClosed: 2\n};\n", "/** EventMap */\nexport type EventMap = {\n  [key: string]: (...args: any[]) => void\n}\n\n/** Typed event emitter. */\nexport interface TypedEventEmitter<Events extends EventMap> {\n  addListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  on<E extends keyof Events>(event: E, listener: Events[E]): this\n  once<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependOnceListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  off<E extends keyof Events>(event: E, listener: Events[E]): this\n  removeAllListeners<E extends keyof Events>(event?: E): this\n  removeListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  emit<E extends keyof Events>(event: E, ...args: Parameters<Events[E]>): boolean\n  rawListeners<E extends keyof Events>(event: E): Events[E][]\n  listeners<E extends keyof Events>(event: E): Events[E][]\n}\n\n/** Client events which can be emitted. */\nexport type ClientEvents = {\n  state: (ctx: StateContext) => void;\n  connecting: (ctx: ConnectingContext) => void;\n  connected: (ctx: ConnectedContext) => void;\n  disconnected: (ctx: DisconnectedContext) => void;\n\n  // Async message coming from a server.\n  message: (ctx: MessageContext) => void;\n  // Listen to errors happening internally. \n  error: (ctx: ErrorContext) => void;\n\n  // Listen for server-side subscription events.\n  subscribed: (ctx: ServerSubscribedContext) => void;\n  subscribing: (ctx: ServerSubscribingContext) => void;\n  unsubscribed: (ctx: ServerUnsubscribedContext) => void;\n  publication: (ctx: ServerPublicationContext) => void;\n  join: (ctx: ServerJoinContext) => void;\n  leave: (ctx: ServerLeaveContext) => void;\n}\n\n/** State of client. */\nexport enum State {\n  Disconnected = \"disconnected\",\n  Connecting = \"connecting\",\n  Connected = \"connected\"\n}\n\n/** Events of Subscription. */\nexport type SubscriptionEvents = {\n  state: (ctx: SubscriptionStateContext) => void;\n  subscribing: (ctx: SubscribingContext) => void;\n  subscribed: (ctx: SubscribedContext) => void;\n  unsubscribed: (ctx: UnsubscribedContext) => void;\n\n  publication: (ctx: PublicationContext) => void;\n  join: (ctx: JoinContext) => void;\n  leave: (ctx: LeaveContext) => void;\n\n  // listen to errors happening internally. \n  error: (ctx: SubscriptionErrorContext) => void;\n}\n\n/** State of Subscription */\nexport enum SubscriptionState {\n  Unsubscribed = \"unsubscribed\",\n  Subscribing = \"subscribing\",\n  Subscribed = \"subscribed\"\n}\n\nexport type TransportName = 'websocket' | 'http_stream' | 'sse' | 'sockjs' | 'webtransport';\n\n/** TransportEndpoint allows configuring transport when using fallback mode */\nexport interface TransportEndpoint {\n  /** transport to use */\n  transport: TransportName;\n  /** endpoint for a selected transport type */\n  endpoint: string;\n}\n\n/** Options for Centrifuge client. */\nexport interface Options {\n  /** select protocol to use. Note that to use Protobuf protocol you need to use CentrifugeProtobuf class. */\n  protocol: 'json' | 'protobuf';\n  /** allows enabling debug mode */\n  debug: boolean;\n  /** allows setting connection token (JWT) */\n  token: string | null;\n  /** allows setting function to get/refresh connection token */\n  getToken: null | ((ctx: ConnectionTokenContext) => Promise<string>);\n  /** data to send to a server with connect command */\n  data: any | null;\n  /** name of client - it's not a unique name of each connection, it's sth to identify from where client connected */\n  name: string;\n  /** version of client */\n  version: string;\n  /** minimum delay between reconnect attemts in milliseconds */\n  minReconnectDelay: number;\n  /** maximum delay between reconnect attemts in milliseconds */\n  maxReconnectDelay: number;\n  /** timeout for operations in milliseconds */\n  timeout: number;\n  /** maximum delay of server pings to detect broken connection in milliseconds */\n  maxServerPingDelay: number;\n  /** provide custom WebSocket constructor, useful for NodeJS env where WebSocket is not available globally */\n  websocket: any | null;\n  /** provide shim for fetch implementation */\n  fetch: any | null;\n  /** provide shim for ReadableStream */\n  readableStream: any | null;\n  /** provide shim for EventSource object */\n  eventsource: any | null;\n  /** provide shim for SockJS object */\n  sockjs: any | null;\n  /** allows modifying options passed to SockJS constructor */\n  sockjsOptions: SockjsOptions;\n  /** which emulation endpoint to use */\n  emulationEndpoint: string;\n}\n\nexport interface SockjsOptions {\n  transports?: string[];\n  timeout?: number;\n}\n\nexport interface StateContext {\n  newState: State;\n  oldState: State;\n}\n\nexport interface ConnectedContext {\n  client: string;\n  transport: string;\n  data?: any;\n}\n\nexport interface ErrorContext {\n  type: string;\n  error: Error;\n  transport?: string;\n}\n\nexport interface Error {\n  code: number;\n  message: string;\n}\n\nexport interface ConnectingContext {\n  code: number;\n  reason: string;\n}\n\nexport interface DisconnectedContext {\n  code: number;\n  reason: string;\n}\n\nexport interface MessageContext {\n  data: any;\n}\n\nexport interface PublicationContext {\n  channel: string;\n  data: any;\n  info?: ClientInfo;\n  offset?: number;\n  tags?: Map<string, string>;\n}\n\nexport interface ClientInfo {\n  client: string;\n  user: string;\n  connInfo?: any;\n  chanInfo?: any;\n}\n\nexport interface JoinContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface LeaveContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface SubscriptionStateContext {\n  channel: string;\n  newState: SubscriptionState;\n  oldState: SubscriptionState;\n}\n\nexport interface ServerSubscribedContext {\n  /** channel of Subscription. */\n  channel: string;\n  /** Subscription is recoverable \u2013 i.e. can automatically recover missied messages */\n  recoverable: boolean;\n  /** Subscription is positioned \u2013 i.e. server tracks message loss on the way from PUB/SUB broker */\n  positioned: boolean;\n  /** streamPosition set when Subscription is recoverable or positioned. */\n  streamPosition?: StreamPosition;\n  /** wasRecovering is true when recovery was used in subscribe request. */\n  wasRecovering: boolean;\n  /** whether or not missed publications may be successfully recovered.  */\n  recovered: boolean;\n  /** custom data for Subscription returned from server. */\n  data?: any;\n}\n\nexport interface SubscribedContext {\n  channel: string;\n  recoverable: boolean;\n  positioned: boolean;\n  streamPosition?: StreamPosition;\n  wasRecovering: boolean;\n  recovered: boolean;\n  data?: any;\n}\n\nexport interface SubscriptionErrorContext {\n  channel: string;\n  type: string;\n  error: Error;\n}\n\nexport interface UnsubscribedContext {\n  channel: string;\n  code: number;\n  reason: string;\n}\n\nexport interface ServerPublicationContext {\n  channel: string;\n  data: any;\n  info?: ClientInfo;\n  offset?: number;\n  tags?: Map<string, string>;\n}\n\nexport interface ServerJoinContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface ServerLeaveContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface ServerUnsubscribedContext {\n  channel: string;\n}\n\nexport interface SubscribingContext {\n  channel: string;\n  code: number;\n  reason: string;\n}\n\nexport interface ServerSubscribingContext {\n  channel: string;\n}\n\nexport interface ConnectionTokenContext {\n}\n\nexport interface SubscriptionTokenContext {\n  channel: string;\n}\n\nexport interface PublishResult {\n}\n\nexport interface RpcResult {\n  data: any;\n}\n\nexport interface PresenceResult {\n  clients: Map<string, ClientInfo>;\n}\n\nexport interface PresenceStatsResult {\n  numClients: number;\n  numUsers: number;\n}\n\nexport interface HistoryResult {\n  publications: PublicationContext[];\n  offset: number;\n  epoch: string;\n}\n\nexport interface HistoryOptions {\n  limit?: number;\n  since?: StreamPosition;\n  reverse?: boolean;\n}\n\n/** SubscriptionOptions can customize Subscription. */\nexport interface SubscriptionOptions {\n  /** allows setting subscription token (JWT) */\n  token: string | null;\n  /** allows setting function to get/refresh subscription token */\n  getToken: null | ((ctx: SubscriptionTokenContext) => Promise<string>);\n  /** data to send to a server with subscribe command */\n  data: any | null;\n  /** force recovery on first subscribe from a provided StreamPosition. */\n  since: StreamPosition | null;\n  /** min delay between resubscribe attemts. */\n  minResubscribeDelay: number;\n  /** max delay between resubscribe attempts. */\n  maxResubscribeDelay: number;\n  /** ask server to make subsription positioned. */\n  positioned: boolean;\n  /** ask server to make subsription recoverable. */\n  recoverable: boolean;\n  /** ask server to send join/leave messages. */\n  joinLeave: boolean;\n}\n\n/** Stream postion describes position of publication inside a stream.  */\nexport interface StreamPosition {\n  offset: number;\n  epoch: string;\n}\n", "/** @internal */\nexport function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n}\n\n/** @internal */\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n}\n\n/** @internal */\nexport function log(level, args) {\n  if (globalThis.console) {\n    const logger = globalThis.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(globalThis.console, args);\n    }\n  }\n}\n\nfunction randomInt(min: number, max: number) { // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/** @internal */\nexport function backoff(step: number, min: number, max: number) {\n  // Full jitter technique, see:\n  // https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n  if (step > 31) { step = 31; }\n  const interval = randomInt(0, Math.min(max, min * Math.pow(2, step)));\n  return Math.min(max, min + interval);\n}\n\n/** @internal */\nexport function errorExists(data: any) {\n  return 'error' in data && data.error !== null;\n}\n\n/** @internal */\nexport function ttlMilliseconds(ttl: number) {\n  // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n  return Math.min(ttl * 1000, 2147483647);\n}\n", "/** @internal */\nexport class SockjsTransport {\n  endpoint: string;\n  options: any;\n  _transport: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n  }\n\n  name() {\n    return 'sockjs';\n  }\n\n  subName() {\n    return 'sockjs-' + this._transport.transport;\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.sockjs !== null;\n  }\n\n  initialize(_protocol: 'json', callbacks: any) {\n    this._transport = new this.options.sockjs(this.endpoint, null, this.options.sockjsOptions);\n\n    this._transport.onopen = () => {\n      callbacks.onOpen();\n    };\n\n    this._transport.onerror = e => {\n      callbacks.onError(e);\n    };\n\n    this._transport.onclose = closeEvent => {\n      callbacks.onClose(closeEvent);\n    };\n\n    this._transport.onmessage = event => {\n      callbacks.onMessage(event.data);\n    };\n  }\n\n  close() {\n    this._transport.close();\n  }\n\n  send(data: any) {\n    this._transport.send(data);\n  }\n}\n", "/** @internal */\nexport class WebsocketTransport {\n  private _transport: any;\n  private endpoint: string;\n  private options: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n  }\n\n  name() {\n    return 'websocket';\n  }\n\n  subName() {\n    return 'websocket';\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.websocket !== undefined && this.options.websocket !== null;\n  }\n\n  initialize(protocol: string, callbacks: any) {\n    let subProtocol = '';\n    if (protocol === 'protobuf') {\n      subProtocol = 'centrifuge-protobuf';\n    }\n    if (subProtocol !== '') {\n      this._transport = new this.options.websocket(this.endpoint, subProtocol);\n    } else {\n      this._transport = new this.options.websocket(this.endpoint);\n    }\n    if (protocol === 'protobuf') {\n      this._transport.binaryType = 'arraybuffer';\n    }\n\n    this._transport.onopen = () => {\n      callbacks.onOpen();\n    };\n\n    this._transport.onerror = e => {\n      callbacks.onError(e);\n    };\n\n    this._transport.onclose = closeEvent => {\n      callbacks.onClose(closeEvent);\n    };\n\n    this._transport.onmessage = event => {\n      callbacks.onMessage(event.data);\n    };\n  }\n\n  close() {\n    this._transport.close();\n  }\n\n  send(data: any) {\n    this._transport.send(data);\n  }\n}\n", "/** @internal */\nexport class HttpStreamTransport {\n  endpoint: string;\n  options: any;\n  _abortController: any | null;\n  _utf8decoder: TextDecoder;\n  _protocol: string;\n\n  constructor(endpoint, options) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._abortController = null;\n    this._utf8decoder = new TextDecoder();\n    this._protocol = 'json';\n  }\n\n  name() {\n    return 'http_stream';\n  }\n\n  subName() {\n    return 'http_stream';\n  }\n\n  emulation() {\n    return true;\n  }\n\n  _handleErrors(response: any) {\n    if (!response.ok) throw new Error(response.status);\n    return response;\n  }\n\n  _fetchEventTarget(self, endpoint: string, options: object) {\n    const eventTarget = new EventTarget();\n    // fetch with connection timeout maybe? https://github.com/github/fetch/issues/175\n    const fetchFunc = self.options.fetch;\n    fetchFunc(endpoint, options)\n      .then(self._handleErrors)\n      .then(response => {\n        eventTarget.dispatchEvent(new Event('open'));\n        let jsonStreamBuf = '';\n        let jsonStreamPos = 0;\n        let protoStreamBuf = new Uint8Array();\n        const reader = response.body.getReader();\n        return new self.options.readableStream({\n          start(controller) {\n            function pump() {\n              return reader.read().then(({ done, value }) => {\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                  eventTarget.dispatchEvent(new Event('close'));\n                  controller.close();\n                  return;\n                }\n                try {\n                  if (self._protocol === 'json') {\n                    jsonStreamBuf += self._utf8decoder.decode(value);\n                    while (jsonStreamPos < jsonStreamBuf.length) {\n                      if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                        const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                        eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                        jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                        jsonStreamPos = 0;\n                      } else {\n                        ++jsonStreamPos;\n                      }\n                    }\n                  } else {\n                    const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n                    mergedArray.set(protoStreamBuf);\n                    mergedArray.set(value, protoStreamBuf.length);\n                    protoStreamBuf = mergedArray;\n\n                    while (true) {\n                      const result = self.options.decoder.decodeReply(protoStreamBuf);\n                      if (result.ok) {\n                        const data = protoStreamBuf.slice(0, result.pos);\n                        eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                        protoStreamBuf = protoStreamBuf.slice(result.pos);\n                        continue;\n                      }\n                      break;\n                    }\n                  }\n                } catch (error) {\n                  // @ts-ignore - improve later.\n                  eventTarget.dispatchEvent(new Event('error', { detail: error }));\n                  eventTarget.dispatchEvent(new Event('close'));\n                  controller.close();\n                  return;\n                }\n                pump();\n              }).catch(function (e) {\n                // @ts-ignore - improve later.\n                eventTarget.dispatchEvent(new Event('error', { detail: e }));\n                eventTarget.dispatchEvent(new Event('close'));\n                controller.close();\n                return;\n              });\n            }\n            return pump();\n          }\n        });\n      })\n      .catch(error => {\n        // @ts-ignore - improve later.\n        eventTarget.dispatchEvent(new Event('error', { detail: error }));\n        eventTarget.dispatchEvent(new Event('close'));\n      });\n    return eventTarget;\n  }\n\n  supported() {\n    return this.options.fetch !== null &&\n      this.options.readableStream !== null &&\n      typeof TextDecoder !== 'undefined' &&\n      typeof AbortController !== 'undefined' &&\n      typeof EventTarget !== 'undefined' &&\n      typeof Event !== 'undefined' &&\n      typeof MessageEvent !== 'undefined' &&\n      typeof Error !== 'undefined';\n  }\n\n  initialize(protocol: string, callbacks: any, initialData: any) {\n    this._protocol = protocol;\n    this._abortController = new AbortController();\n    let headers: any;\n    let body: any;\n    if (protocol === 'json') {\n      headers = {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      };\n      body = initialData;\n    } else {\n      headers = {\n        'Accept': 'application/octet-stream',\n        'Content-Type': 'application/octet-stream'\n      };\n      body = initialData;\n    }\n\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n      cache: 'no-cache',\n      signal: this._abortController.signal\n    }\n\n    const eventTarget = this._fetchEventTarget(\n      this,\n      this.endpoint,\n      fetchOptions\n    );\n\n    eventTarget.addEventListener('open', () => {\n      callbacks.onOpen();\n    });\n\n    eventTarget.addEventListener('error', (e) => {\n      this._abortController.abort();\n      callbacks.onError(e);\n    });\n\n    eventTarget.addEventListener('close', () => {\n      this._abortController.abort();\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n\n    eventTarget.addEventListener('message', (e: any) => {\n      callbacks.onMessage(e.data);\n    });\n  }\n\n  close() {\n    this._abortController.abort();\n  }\n\n  send(data: any, session: string, node: string) {\n    let headers: any;\n    let body: any;\n    const req = {\n      session: session,\n      node: node,\n      data: data\n    };\n    if (this._protocol === 'json') {\n      headers = {\n        'Content-Type': 'application/json'\n      };\n      body = JSON.stringify(req);\n    } else {\n      headers = {\n        'Content-Type': 'application/octet-stream'\n      };\n      body = this.options.encoder.encodeEmulationRequest(req);\n    }\n\n    const fetchFunc = this.options.fetch;\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n      cache: 'no-cache'\n    }\n    fetchFunc(this.options.emulationEndpoint, fetchOptions);\n  }\n}\n", "/** @internal */\nexport class SseTransport {\n  endpoint: string;\n  options: any;\n  _protocol: string;\n  _transport: any;\n  _onClose: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._protocol = 'json';\n    this._transport = null;\n    this._onClose = null;\n  }\n\n  name() {\n    return 'sse';\n  }\n\n  subName() {\n    return 'sse';\n  }\n\n  emulation() {\n    return true;\n  }\n\n  supported() {\n    return this.options.eventsource !== null && this.options.fetch !== null;\n  }\n\n  initialize(_protocol: 'json', callbacks: any, initialData: any) {\n    let url: any;\n    if (globalThis && globalThis.document && globalThis.document.baseURI) {\n      // Handle case when endpoint is relative, like //example.com/connection/sse\n      url = new URL(this.endpoint, globalThis.document.baseURI);\n    } else {\n      url = new URL(this.endpoint);\n    }\n    url.searchParams.append('cf_connect', initialData);\n\n    const eventsourceOptions = {}\n    const eventSource = new this.options.eventsource(url.toString(), eventsourceOptions);\n    this._transport = eventSource;\n\n    const self = this;\n\n    eventSource.onopen = function () {\n      callbacks.onOpen();\n    };\n\n    eventSource.onerror = function (e) {\n      eventSource.close();\n      callbacks.onError(e);\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    };\n\n    eventSource.onmessage = function (e) {\n      callbacks.onMessage(e.data);\n    };\n\n    self._onClose = function () {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    };\n  }\n\n  close() {\n    this._transport.close();\n    if (this._onClose !== null) {\n      this._onClose();\n    }\n  }\n\n  send(data: any, session: string, node: string) {\n    const req = {\n      session: session,\n      node: node,\n      data: data\n    };\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n    const body = JSON.stringify(req);\n    const fetchFunc = this.options.fetch;\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n      cache: 'no-cache'\n    }\n    fetchFunc(this.options.emulationEndpoint, fetchOptions);\n  }\n}\n", "/** @internal */\nexport class WebtransportTransport {\n  private _transport: any;\n  private _stream: any;\n  private _writer: any;\n  private endpoint: string;\n  private options: any;\n  _utf8decoder: TextDecoder;\n  _protocol: string;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n    this._stream = null;\n    this._writer = null;\n    this._utf8decoder = new TextDecoder();\n    this._protocol = 'json';\n  }\n\n  name() {\n    return 'webtransport';\n  }\n\n  subName() {\n    return 'webtransport';\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.webtransport !== undefined && this.options.webtransport !== null;\n  }\n\n  async initialize(protocol: string, callbacks: any) {\n    let url: any;\n    if (globalThis && globalThis.document && globalThis.document.baseURI) {\n      // Handle case when endpoint is relative, like //example.com/connection/webtransport\n      url = new URL(this.endpoint, globalThis.document.baseURI);\n    } else {\n      url = new URL(this.endpoint);\n    }\n    if (protocol === 'protobuf') {\n      url.searchParams.append('cf_protocol', 'protobuf');\n    }\n\n    this._protocol = protocol;\n    const eventTarget = new EventTarget();\n\n    this._transport = new this.options.webtransport(url.toString());\n    this._transport.closed.then(() => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    }).catch(() => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n    try {\n      await this._transport.ready;\n    } catch {\n      this.close();\n      return;\n    }\n    let stream: any;\n    try {\n      stream = await this._transport.createBidirectionalStream();\n    } catch {\n      this.close();\n      return;\n    }\n    this._stream = stream;\n    this._writer = this._stream.writable.getWriter();\n\n    eventTarget.addEventListener('close', () => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n\n    eventTarget.addEventListener('message', (e: any) => {\n      callbacks.onMessage(e.data);\n    });\n\n    this._startReading(eventTarget);\n\n    callbacks.onOpen();\n  }\n\n  async _startReading(eventTarget: any) {\n    const reader = this._stream.readable.getReader();\n    let jsonStreamBuf = '';\n    let jsonStreamPos = 0;\n    let protoStreamBuf = new Uint8Array();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (value.length > 0) {\n          if (this._protocol === 'json') {\n            jsonStreamBuf += this._utf8decoder.decode(value);\n            while (jsonStreamPos < jsonStreamBuf.length) {\n              if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                jsonStreamPos = 0;\n              } else {\n                ++jsonStreamPos;\n              }\n            }\n          } else {\n            const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n            mergedArray.set(protoStreamBuf);\n            mergedArray.set(value, protoStreamBuf.length);\n            protoStreamBuf = mergedArray;\n\n            while (true) {\n              const result = this.options.decoder.decodeReply(protoStreamBuf);\n              if (result.ok) {\n                const data = protoStreamBuf.slice(0, result.pos);\n                eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                protoStreamBuf = protoStreamBuf.slice(result.pos);\n                continue;\n              }\n              break;\n            }\n          }\n        }\n        if (done) {\n          break;\n        }\n      }\n    } catch {\n      eventTarget.dispatchEvent(new Event('close'));\n    }\n  }\n\n  async close() {\n    try {\n      if (this._writer) {\n        await this._writer.close();\n      }\n      this._transport.close();\n    } catch (e) {\n      // already closed.\n    }\n  }\n\n  async send(data: any) {\n    let binary: Uint8Array;\n    if (this._protocol === 'json') {\n      // Need extra \\n since WT is non-frame protocol. \n      binary = new TextEncoder().encode(data + '\\n');\n    } else {\n      binary = data;\n    }\n    try {\n      await this._writer.write(binary);\n    } catch (e) {\n      this.close();\n    }\n  }\n}\n", "/** @internal */\nexport class JsonEncoder {\n  encodeCommands(commands: any[]): string {\n    return commands.map(c => JSON.stringify(c)).join('\\n');\n  }\n}\n\n/** @internal */\nexport class JsonDecoder {\n  decodeReplies(data: string): any[] {\n    return data.trim().split('\\n').map(r => JSON.parse(r));\n  }\n}\n", "import { Subscription } from './subscription';\nimport {\n  errorCodes, disconnectedCodes,\n  connectingCodes, subscribingCodes\n} from './codes';\n\nimport { SockjsTransport } from './transport_sockjs';\nimport { WebsocketTransport } from './transport_websocket';\nimport { HttpStreamTransport } from './transport_http_stream';\nimport { SseTransport } from './transport_sse';\nimport { WebtransportTransport } from './transport_webtransport';\n\nimport { JsonEncoder, JsonDecoder } from './json';\n\nimport {\n  isFunction, log, startsWith, errorExists,\n  backoff, ttlMilliseconds\n} from './utils';\n\nimport {\n  State, Options, SubscriptionState, ClientEvents,\n  TypedEventEmitter, RpcResult, SubscriptionOptions,\n  HistoryOptions, HistoryResult, PublishResult,\n  PresenceResult, PresenceStatsResult, SubscribedContext,\n  TransportEndpoint,\n} from './types';\n\nimport EventEmitter from 'events';\n\nconst defaults: Options = {\n  protocol: 'json',\n  token: null,\n  getToken: null,\n  data: null,\n  debug: false,\n  name: 'js',\n  version: '',\n  fetch: null,\n  readableStream: null,\n  websocket: null,\n  eventsource: null,\n  sockjs: null,\n  sockjsOptions: {},\n  emulationEndpoint: '/emulation',\n  minReconnectDelay: 500,\n  maxReconnectDelay: 20000,\n  timeout: 5000,\n  maxServerPingDelay: 10000,\n}\n\ninterface serverSubscription {\n  offset: number;\n  epoch: string;\n  recoverable: boolean;\n}\n\n/** Centrifuge is a Centrifuge/Centrifugo bidirectional client. */\nexport class Centrifuge extends (EventEmitter as new () => TypedEventEmitter<ClientEvents>) {\n  state: State;\n  private _endpoint: string | Array<TransportEndpoint>;\n  private _emulation: boolean;\n  private _transports: any[];\n  private _currentTransportIndex: number;\n  private _triedAllTransports: boolean;\n  private _transportWasOpen: boolean;\n  private _transport?: any;\n  private _transportClosed: boolean;\n  private _reconnectTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _reconnectAttempts: number;\n  private _client: null;\n  private _session: string;\n  private _node: string;\n  private _subs: Record<string, Subscription>;\n  private _serverSubs: Record<string, serverSubscription>;\n  private _commandId: number;\n  private _commands: any[];\n  private _batching: boolean;\n  private _refreshRequired: boolean;\n  private _refreshTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _callbacks: Record<number, any>;\n  private _token?: string;\n  private _dispatchPromise: Promise<void>;\n  private _serverPing: number;\n  private _serverPingTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _sendPong: boolean;\n  private _promises: Record<number, any>;\n  private _promiseId: number;\n\n  private _debugEnabled: boolean;\n  private _config: Options;\n  protected _encoder: any;\n  protected _decoder: any;\n\n  static State: { Disconnected: string; Connecting: string; Connected: string; };\n  static SubscriptionState: { Unsubscribed: string; Subscribing: string; Subscribed: string; };\n\n  /** Constructs Centrifuge client. Call connect() method to start connecting. */\n  constructor(endpoint: string | Array<TransportEndpoint>, options?: Partial<Options>) {\n    super();\n    this.state = State.Disconnected;\n    this._endpoint = endpoint;\n    this._emulation = false;\n    this._transports = [];\n    this._currentTransportIndex = 0;\n    this._triedAllTransports = false;\n    this._transportWasOpen = false;\n    this._transport = null;\n    this._transportClosed = true;\n    this._encoder = null;\n    this._decoder = null;\n    this._reconnectTimeout = null;\n    this._reconnectAttempts = 0;\n    this._client = null;\n    this._session = '';\n    this._node = '';\n    this._subs = {};\n    this._serverSubs = {};\n    this._commandId = 0;\n    this._commands = [];\n    this._batching = false;\n    this._refreshRequired = false;\n    this._refreshTimeout = null;\n    this._callbacks = {};\n    this._token = undefined;\n    this._dispatchPromise = Promise.resolve();\n    this._serverPing = 0;\n    this._serverPingTimeout = null;\n    this._sendPong = false;\n    this._promises = {};\n    this._promiseId = 0;\n    this._debugEnabled = false;\n\n    this._config = { ...defaults, ...options };\n    this._configure();\n\n    if (this._debugEnabled) {\n      this.on('state', (ctx) => {\n        this._debug('client state', ctx.oldState, '->', ctx.newState);\n      });\n      this.on('error', (ctx) => {\n        this._debug('client error', ctx);\n      });\n    } else {\n      // Avoid unhandled exception in EventEmitter for non-set error handler.\n      this.on('error', function () { Function.prototype(); });\n    }\n  }\n\n  /** newSubscription allocates new Subscription to a channel. Since server only allows \n   * one subscription per channel per client this method throws if client already has \n   * channel subscription in internal registry.\n   * */\n  newSubscription(channel: string, options?: Partial<SubscriptionOptions>): Subscription {\n    if (this.getSubscription(channel) !== null) {\n      throw new Error('Subscription to the channel ' + channel + ' already exists');\n    }\n    const sub = new Subscription(this, channel, options);\n    this._subs[channel] = sub;\n    return sub;\n  }\n\n  /** getSubscription returns Subscription if it's registered in the internal \n   * registry or null. */\n  getSubscription(channel: string): Subscription | null {\n    return this._getSub(channel);\n  }\n\n  /** removeSubscription allows removing Subcription from the internal registry. Subscrption \n   * must be in unsubscribed state. */\n  removeSubscription(sub: Subscription | null) {\n    if (!sub) {\n      return;\n    }\n    if (sub.state !== SubscriptionState.Unsubscribed) {\n      sub.unsubscribe();\n    }\n    this._removeSubscription(sub);\n  }\n\n  /** Get a map with all current client-side subscriptions. */\n  subscriptions(): Record<string, Subscription> {\n    return this._subs;\n  }\n\n  /** ready returns a Promise which resolves upon client goes to Connected \n   * state and rejects in case of client goes to Disconnected or Failed state.\n   * Users can provide optional timeout in milliseconds. */\n  ready(timeout?: number): Promise<void> {\n    if (this.state === State.Disconnected) {\n      return Promise.reject({ code: errorCodes.clientDisconnected, message: 'client disconnected' });\n    }\n    if (this.state === State.Connected) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const ctx: any = {\n        resolve: res,\n        reject: rej\n      };\n      if (timeout) {\n        ctx.timeout = setTimeout(function () {\n          rej({ code: errorCodes.timeout, message: 'timeout' });\n        }, timeout);\n      }\n      this._promises[this._nextPromiseId()] = ctx;\n    });\n  }\n\n  /** connect to a server. */\n  connect() {\n    if (this._isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._isConnecting()) {\n      this._debug('connect called when already connecting');\n      return;\n    }\n    this._reconnectAttempts = 0;\n    this._startConnecting();\n  }\n\n  /** disconnect from a server. */\n  disconnect() {\n    this._disconnect(disconnectedCodes.disconnectCalled, 'disconnect called', false);\n  }\n\n  /** send asynchronous data to a server (without any response from a server \n   * expected, see rpc method if you need response). */\n  send(data: any): Promise<void> {\n    const cmd = {\n      send: {\n        data: data\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      const sent = self._transportSendCommands([cmd]); // can send message to server without id set\n      if (!sent) {\n        return Promise.reject(self._createErrorObject(errorCodes.transportWriteError, 'transport write error'));\n      }\n      return Promise.resolve();\n    });\n  }\n\n  /** rpc to a server - i.e. a call which waits for a response with data. */\n  rpc(method: string, data: any): Promise<RpcResult> {\n    const cmd = {\n      rpc: {\n        method: method,\n        data: data\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        return {\n          'data': reply.rpc.data\n        };\n      });\n    });\n  }\n\n  /** publish data to a channel. */\n  publish(channel: string, data: any): Promise<PublishResult> {\n    const cmd = {\n      publish: {\n        channel: channel,\n        data: data\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function () {\n        return {};\n      });\n    });\n  }\n\n  /** history for a channel. By default it does not return publications (only current\n   *  StreamPosition data) \u2013 provide an explicit limit > 0 to load publications.*/\n  history(channel: string, options?: HistoryOptions): Promise<HistoryResult> {\n    const cmd = {\n      history: this._getHistoryRequest(channel, options)\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        const result = reply.history;\n        const publications: any[] = [];\n        if (result.publications) {\n          for (let i = 0; i < result.publications.length; i++) {\n            publications.push(self._getPublicationContext(channel, result.publications[i]));\n          }\n        }\n        return {\n          'publications': publications,\n          'epoch': result.epoch || '',\n          'offset': result.offset || 0\n        };\n      });\n    });\n  }\n\n  /** presence for a channel. */\n  presence(channel: string): Promise<PresenceResult> {\n    const cmd = {\n      presence: {\n        channel: channel\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        return {\n          'clients': reply.presence.presence\n        };\n      });\n    });\n  }\n\n  /** presence stats for a channel. */\n  presenceStats(channel: string): Promise<PresenceStatsResult> {\n    const cmd = {\n      'presence_stats': {\n        channel: channel\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        const result = reply.presence_stats;\n        return {\n          'numUsers': result.num_users,\n          'numClients': result.num_clients\n        };\n      });\n    });\n  }\n\n  /** start command batching (collect into temporary buffer without sending to a server) \n   * until stopBatching called.*/\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._batching = true;\n  }\n\n  /** stop batching commands and flush collected commands to the \n   * network (all in one request/frame).*/\n  stopBatching() {\n    const self = this;\n    // Why so nested? Two levels here requred to deal with promise resolving queue.\n    // In Subscription case we wait 2 futures before sending data to connection.\n    // Otherwise _batching becomes false before batching decision has a chance to be executed.\n    Promise.resolve().then(function () {\n      Promise.resolve().then(function () {\n        self._batching = false;\n        self._flush();\n      })\n    })\n  }\n\n  private _debug(...args: any[]) {\n    if (!this._debugEnabled) {\n      return;\n    }\n    log('debug', args);\n  }\n\n  /** @internal */\n  private _setFormat(format: 'json' | 'protobuf') {\n    if (this._formatOverride(format)) {\n      return;\n    }\n    if (format === 'protobuf') {\n      throw new Error('not implemented by JSON-only Centrifuge client, use client with Protobuf support');\n    }\n    this._encoder = new JsonEncoder();\n    this._decoder = new JsonDecoder();\n  }\n\n  /** @internal */\n  protected _formatOverride(_format: 'json' | 'protobuf') {\n    return false;\n  }\n\n  private _configure() {\n    if (!('Promise' in globalThis)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    if (!this._endpoint) {\n      throw new Error('endpoint configuration required');\n    }\n\n    if (this._config.protocol !== 'json' && this._config.protocol !== 'protobuf') {\n      throw new Error('unsupported protocol ' + this._config.protocol);\n    }\n\n    if (this._config.token !== null) {\n      this._token = this._config.token;\n    }\n\n    this._setFormat('json');\n    if (this._config.protocol === 'protobuf') {\n      this._setFormat('protobuf');\n    }\n\n    if (this._config.debug === true ||\n      (typeof localStorage !== 'undefined' && localStorage.getItem('centrifuge.debug'))) {\n      this._debugEnabled = true;\n    }\n\n    this._debug('config', this._config);\n\n    if (typeof this._endpoint === 'string') {\n      // Single address.\n    } else if (typeof this._endpoint === 'object' && this._endpoint instanceof Array) {\n      this._transports = this._endpoint;\n      this._emulation = true;\n      for (const i in this._transports) {\n        const transportConfig = this._transports[i];\n        if (!transportConfig.endpoint || !transportConfig.transport) {\n          throw new Error('malformed transport configuration');\n        }\n        const transportName = transportConfig.transport;\n        if (['websocket', 'http_stream', 'sse', 'sockjs', 'webtransport'].indexOf(transportName) < 0) {\n          throw new Error('unsupported transport name: ' + transportName);\n        }\n      }\n    } else {\n      throw new Error('unsupported url configuration type: only string or array of objects are supported');\n    }\n  }\n\n  private _setState(newState: State) {\n    if (this.state !== newState) {\n      const oldState = this.state;\n      this.state = newState;\n      this.emit('state', { newState, oldState });\n      return true;\n    }\n    return false;\n  }\n\n  private _isDisconnected() {\n    return this.state === State.Disconnected;\n  }\n\n  private _isConnecting() {\n    return this.state === State.Connecting;\n  }\n\n  private _isConnected() {\n    return this.state === State.Connected;\n  }\n\n  private _nextCommandId() {\n    return ++this._commandId;\n  }\n\n  private _getReconnectDelay() {\n    const delay = backoff(this._reconnectAttempts, this._config.minReconnectDelay, this._config.maxReconnectDelay);\n    this._reconnectAttempts += 1;\n    return delay;\n  }\n\n  private _clearOutgoingRequests() {\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback({ error: this._createErrorObject(errorCodes.connectionClosed, 'connection closed') });\n      }\n    }\n    this._callbacks = {};\n  }\n\n  private _clearConnectedState() {\n    this._client = null;\n    this._clearServerPingTimeout();\n    this._clearRefreshTimeout();\n\n    // fire events for client-side subscriptions.\n    for (const channel in this._subs) {\n      if (!this._subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = this._subs[channel];\n      if (sub.state === SubscriptionState.Subscribed) {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        sub._setSubscribing(subscribingCodes.transportClosed, 'transport closed');\n      }\n    }\n\n    // fire events for server-side subscriptions.\n    for (const channel in this._serverSubs) {\n      if (this._serverSubs.hasOwnProperty(channel)) {\n        this.emit('subscribing', { channel: channel });\n      }\n    }\n  }\n\n  private _handleWriteError(commands: any[]) {\n    for (const command of commands) {\n      const id = command.id;\n      if (!(id in this._callbacks)) {\n        continue;\n      }\n      const callbacks = this._callbacks[id];\n      clearTimeout(this._callbacks[id].timeout);\n      delete this._callbacks[id];\n      const errback = callbacks.errback;\n      errback({ error: this._createErrorObject(errorCodes.transportWriteError, 'transport write error') });\n    }\n  }\n\n  private _transportSendCommands(commands: any[]) {\n    if (!commands.length) {\n      return true;\n    }\n    if (!this._transport) {\n      return false\n    }\n    try {\n      this._transport.send(this._encoder.encodeCommands(commands), this._session, this._node);\n    } catch (e) {\n      this._debug('error writing commands', e);\n      this._handleWriteError(commands);\n      return false;\n    }\n    return true;\n  }\n\n  private _initializeTransport() {\n    let websocket: any;\n    if (this._config.websocket !== null) {\n      websocket = this._config.websocket;\n    } else {\n      if (!(typeof globalThis.WebSocket !== 'function' && typeof globalThis.WebSocket !== 'object')) {\n        websocket = globalThis.WebSocket;\n      }\n    }\n\n    let sockjs = null;\n    if (this._config.sockjs !== null) {\n      sockjs = this._config.sockjs;\n    } else {\n      if (typeof globalThis.SockJS !== 'undefined') {\n        sockjs = globalThis.SockJS;\n      }\n    }\n\n    let eventsource: any = null;\n    if (this._config.eventsource !== null) {\n      eventsource = this._config.eventsource;\n    } else {\n      if (typeof globalThis.EventSource !== 'undefined') {\n        eventsource = globalThis.EventSource;\n      }\n    }\n\n    let fetchFunc: any = null;\n    if (this._config.fetch !== null) {\n      fetchFunc = this._config.fetch;\n    } else {\n      if (typeof globalThis.fetch !== 'undefined') {\n        fetchFunc = globalThis.fetch;\n      }\n    }\n\n    let readableStream: any = null;\n    if (this._config.readableStream !== null) {\n      readableStream = this._config.readableStream;\n    } else {\n      if (typeof globalThis.ReadableStream !== 'undefined') {\n        readableStream = globalThis.ReadableStream;\n      }\n    }\n\n    if (!this._emulation) {\n      if (startsWith(this._endpoint, 'http')) {\n        throw new Error('Provide explicit transport endpoints configuration in case of using HTTP (i.e. using array of TransportEndpoint instead of a single string), or use ws(s):// scheme in an endpoint if you aimed using WebSocket transport');\n      } else {\n        this._debug('client will use websocket');\n        this._transport = new WebsocketTransport(this._endpoint as string, {\n          websocket: websocket\n        });\n        if (!this._transport.supported()) {\n          throw new Error('WebSocket not available');\n        }\n      }\n    } else {\n      if (this._currentTransportIndex >= this._transports.length) {\n        this._triedAllTransports = true;\n        this._currentTransportIndex = 0;\n      }\n      let count = 0;\n      while (true) {\n        if (count >= this._transports.length) {\n          throw new Error('no supported transport found');\n        }\n        const transportConfig = this._transports[this._currentTransportIndex];\n        const transportName = transportConfig.transport;\n        const transportEndpoint = transportConfig.endpoint;\n\n        if (transportName === 'websocket') {\n          this._debug('trying websocket transport');\n          this._transport = new WebsocketTransport(transportEndpoint, {\n            websocket: websocket\n          });\n          if (!this._transport.supported()) {\n            this._debug('websocket transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'webtransport') {\n          this._debug('trying webtransport transport');\n          this._transport = new WebtransportTransport(transportEndpoint, {\n            webtransport: globalThis.WebTransport,\n            decoder: this._decoder,\n            encoder: this._encoder\n          });\n          if (!this._transport.supported()) {\n            this._debug('webtransport transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'http_stream') {\n          this._debug('trying http_stream transport');\n          this._transport = new HttpStreamTransport(transportEndpoint, {\n            fetch: fetchFunc,\n            readableStream: readableStream,\n            emulationEndpoint: this._config.emulationEndpoint,\n            decoder: this._decoder,\n            encoder: this._encoder\n          });\n          if (!this._transport.supported()) {\n            this._debug('http_stream transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'sse') {\n          this._debug('trying sse transport');\n          this._transport = new SseTransport(transportEndpoint, {\n            eventsource: eventsource,\n            fetch: fetchFunc,\n            emulationEndpoint: this._config.emulationEndpoint,\n          });\n          if (!this._transport.supported()) {\n            this._debug('sse transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'sockjs') {\n          this._debug('trying sockjs');\n          this._transport = new SockjsTransport(transportEndpoint, {\n            sockjs: sockjs,\n            sockjsOptions: this._config.sockjsOptions\n          });\n          if (!this._transport.supported()) {\n            this._debug('sockjs transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else {\n          throw new Error('unknown transport ' + transportName);\n        }\n        break;\n      }\n    }\n\n    const self = this;\n\n    let transportName: string;\n    let wasOpen = false;\n\n    let optimistic = true;\n    if (this._transport.name() === 'sse') {\n      // Avoid using optimistic subscriptions with SSE/EventSource as we are sending\n      // initial data in URL params. URL is recommended to be 2048 chars max \u2013 so adding\n      // subscription data may be risky.\n      optimistic = false;\n    }\n\n    const initialCommands: any[] = [];\n\n    if (this._transport.emulation()) {\n      const connectCommand = self._sendConnect(true);\n      initialCommands.push(connectCommand);\n      if (optimistic) {\n        const subscribeCommands: any[] = self._sendSubscribeCommands(true, true);\n        for (const i in subscribeCommands) {\n          initialCommands.push(subscribeCommands[i]);\n        }\n      }\n    }\n\n    const initialData = this._encoder.encodeCommands(initialCommands);\n\n    this._transport.initialize(this._config.protocol, {\n      onOpen: function () {\n        wasOpen = true;\n        transportName = self._transport.subName();\n        self._debug(transportName, 'transport open');\n        self._transportWasOpen = true;\n        self._transportClosed = false;\n\n        if (self._transport.emulation()) {\n          return;\n        }\n        self.startBatching();\n        self._sendConnect(false);\n        if (optimistic) {\n          self._sendSubscribeCommands(true, false);\n        }\n        self.stopBatching();\n      },\n      onError: function (e: any) {\n        self._debug('transport level error', e);\n      },\n      onClose: function (closeEvent) {\n        self._debug(self._transport.name(), 'transport closed');\n        self._transportClosed = true;\n\n        let reason = 'connection closed';\n        let needReconnect = true;\n        let code = 0;\n\n        if (closeEvent && 'code' in closeEvent && closeEvent.code) {\n          code = closeEvent.code;\n        }\n\n        if (closeEvent && closeEvent.reason) {\n          try {\n            const advice = JSON.parse(closeEvent.reason);\n            reason = advice.reason;\n            needReconnect = advice.reconnect;\n          } catch (e) {\n            reason = closeEvent.reason;\n            if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n              needReconnect = false;\n            }\n          }\n        }\n\n        if (code < 3000) {\n          if (code === 1009) {\n            code = disconnectedCodes.messageSizeLimit;\n            reason = 'message size limit exceeded';\n            needReconnect = false;\n          } else {\n            code = connectingCodes.transportClosed;\n            reason = 'transport closed';\n          }\n          if (self._emulation && !self._transportWasOpen) {\n            self._currentTransportIndex++;\n            if (self._currentTransportIndex >= self._transports.length) {\n              self._triedAllTransports = true;\n              self._currentTransportIndex = 0;\n            }\n          }\n        } else {\n          // Codes >= 3000 are sent from a server application level.\n          self._transportWasOpen = true;\n        }\n\n        let isInitialHandshake = false;\n        if (self._emulation && !self._transportWasOpen && !self._triedAllTransports) {\n          isInitialHandshake = true;\n        }\n\n        if (self._isConnecting() && !wasOpen) {\n          self.emit('error', {\n            type: 'transport',\n            error: {\n              code: errorCodes.transportClosed,\n              message: 'transport closed'\n            },\n            transport: self._transport.name()\n          });\n        }\n\n        self._disconnect(code, reason, needReconnect);\n\n        if (self._isConnecting()) {\n          let delay = self._getReconnectDelay();\n          if (isInitialHandshake) {\n            delay = 0;\n          }\n          self._debug('reconnect after ' + delay + ' milliseconds');\n          self._reconnectTimeout = setTimeout(() => {\n            self._startReconnecting();\n          }, delay);\n        }\n      },\n      onMessage: function (data) {\n        self._dataReceived(data);\n      }\n    }, initialData);\n  }\n\n  private _sendConnect(skipSending: boolean): any {\n    const connectCommand = this._constructConnectCommand();\n    const self = this;\n    this._call(connectCommand, skipSending).then(resolveCtx => {\n      // @ts-ignore = improve later.\n      const result = resolveCtx.reply.connect;\n      self._connectResponse(result);\n      // @ts-ignore - improve later.\n      if (resolveCtx.next) {\n        // @ts-ignore - improve later.\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      self._connectError(rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n    return connectCommand;\n  }\n\n  private _startReconnecting() {\n    if (!this._isConnecting()) {\n      return;\n    }\n\n    const needTokenRefresh = this._refreshRequired || (!this._token && this._config.getToken !== null);\n    if (!needTokenRefresh) {\n      this._initializeTransport();\n      return;\n    }\n\n    const self = this;\n\n    this._getToken().then(function (token) {\n      if (!self._isConnecting()) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      self._debug('connection token refreshed');\n      self._initializeTransport();\n    }).catch(function (e) {\n      if (!self._isConnecting()) {\n        return;\n      }\n      self.emit('error', {\n        'type': 'connectToken',\n        'error': {\n          code: errorCodes.clientConnectToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      const delay = self._getReconnectDelay();\n      self._debug('error on connection token refresh, reconnect after ' + delay + ' milliseconds', e);\n      self._reconnectTimeout = setTimeout(() => {\n        self._startReconnecting();\n      }, delay);\n    });\n  }\n\n  private _connectError(err: any) {\n    if (this.state !== State.Connecting) {\n      return;\n    }\n    if (err.code === 109) { // token expired.\n      // next connect attempt will try to refresh token.\n      this._refreshRequired = true;\n    }\n    if (err.code < 100 || err.temporary === true || err.code === 109) {\n      this.emit('error', {\n        'type': 'connect',\n        'error': err\n      });\n      // Not yet connected, closing transport is enough.\n      if (this._transport && !this._transportClosed) {\n        this._transportClosed = true;\n        this._transport.close();\n      }\n    } else {\n      this._disconnect(err.code, err.message, false);\n    }\n  }\n\n  private _constructConnectCommand(): any {\n    const req: any = {};\n\n    if (this._token) {\n      req.token = this._token;\n    }\n    if (this._config.data) {\n      req.data = this._config.data;\n    }\n    if (this._config.name) {\n      req.name = this._config.name;\n    }\n    if (this._config.version) {\n      req.version = this._config.version;\n    }\n\n    const subs = {};\n    let hasSubs = false;\n    for (const channel in this._serverSubs) {\n      if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n        hasSubs = true;\n        const sub = {\n          'recover': true\n        };\n        if (this._serverSubs[channel].offset) {\n          sub['offset'] = this._serverSubs[channel].offset;\n        }\n        if (this._serverSubs[channel].epoch) {\n          sub['epoch'] = this._serverSubs[channel].epoch;\n        }\n        subs[channel] = sub;\n      }\n    }\n    if (hasSubs) {\n      req.subs = subs;\n    }\n    return {\n      connect: req\n    };\n  }\n\n  private _getHistoryRequest(channel: string, options?: HistoryOptions) {\n    const req: any = {\n      channel: channel\n    };\n    if (options !== undefined) {\n      if (options.since) {\n        req.since = {\n          offset: options.since.offset\n        };\n        if (options.since.epoch) {\n          req.since.epoch = options.since.epoch;\n        }\n      }\n      if (options.limit !== undefined) {\n        req.limit = options.limit;\n      }\n      if (options.reverse === true) {\n        req.reverse = true;\n      }\n    }\n    return req;\n  }\n\n  private _methodCall(): any {\n    if (this._isConnected()) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const timeout = setTimeout(function () {\n        rej({ code: errorCodes.timeout, message: 'timeout' });\n      }, this._config.timeout);\n      this._promises[this._nextPromiseId()] = {\n        timeout: timeout,\n        resolve: res,\n        reject: rej\n      };\n    });\n  }\n\n  private _callPromise(cmd: any, resultCB: any): any {\n    return new Promise((resolve, reject) => {\n      this._call(cmd, false).then(resolveCtx => {\n        // @ts-ignore - improve later.\n        resolve(resultCB(resolveCtx.reply));\n        // @ts-ignore - improve later.\n        if (resolveCtx.next) {\n          // @ts-ignore - improve later.\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        reject(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    });\n  }\n\n  private _dataReceived(data) {\n    if (this._serverPing > 0) {\n      this._waitServerPing();\n    }\n    const replies = this._decoder.decodeReplies(data);\n    // We have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    this._dispatchPromise = this._dispatchPromise.then(() => {\n      let finishDispatch;\n      this._dispatchPromise = new Promise(resolve => {\n        finishDispatch = resolve;\n      });\n      this._dispatchSynchronized(replies, finishDispatch);\n    });\n  }\n\n  private _dispatchSynchronized(replies: any[], finishDispatch: any) {\n    let p: Promise<unknown> = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    p = p.then(() => {\n      finishDispatch();\n    });\n  }\n\n  private _dispatchReply(reply: any) {\n    let next: any;\n    const p = new Promise(resolve => {\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      if (!reply.push) {\n        this._handleServerPing(next);\n      } else {\n        this._handlePush(reply.push, next);\n      }\n    }\n\n    return p;\n  }\n\n  private _call(cmd: any, skipSending: boolean) {\n    return new Promise((resolve, reject) => {\n      cmd.id = this._nextCommandId();\n      this._registerCall(cmd.id, resolve, reject);\n      if (!skipSending) {\n        this._addCommand(cmd);\n      }\n    });\n  }\n\n  private _startConnecting() {\n    this._debug('start connecting');\n    if (this._setState(State.Connecting)) {\n      this.emit('connecting', { code: connectingCodes.connectCalled, reason: 'connect called' });\n    }\n    this._client = null;\n    this._startReconnecting();\n  }\n\n  private _disconnect(code: number, reason: string, reconnect: boolean) {\n    if (this._isDisconnected()) {\n      return;\n    }\n\n    const previousState = this.state;\n\n    const ctx = {\n      code: code,\n      reason: reason\n    };\n\n    let needEvent = false;\n\n    if (reconnect) {\n      needEvent = this._setState(State.Connecting);\n    } else {\n      needEvent = this._setState(State.Disconnected);\n      this._rejectPromises({ code: errorCodes.clientDisconnected, message: 'disconnected' });\n    }\n\n    this._clearOutgoingRequests();\n\n    if (previousState === State.Connecting) {\n      this._clearReconnectTimeout();\n    }\n    if (previousState === State.Connected) {\n      this._clearConnectedState();\n    }\n\n    if (needEvent) {\n      if (this._isConnecting()) {\n        this.emit('connecting', ctx);\n      } else {\n        this.emit('disconnected', ctx);\n      }\n    }\n\n    if (this._transport && !this._transportClosed) {\n      this._transportClosed = true;\n      this._transport.close();\n    }\n  }\n\n  private _failUnauthorized() {\n    this._disconnect(disconnectedCodes.unauthorized, 'unauthorized', false);\n  }\n\n  private _getToken() {\n    this._debug('get connection token');\n    if (!this._config.getToken) {\n      throw new Error('provide a function to get connection token');\n    }\n    return this._config.getToken({});\n  }\n\n  private _refresh() {\n    const clientId = this._client;\n    const self = this;\n    this._getToken().then(function (token) {\n      if (clientId !== self._client) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      self._debug('connection token refreshed');\n\n      if (!self._isConnected()) {\n        return;\n      }\n\n      const cmd = {\n        refresh: { token: self._token }\n      };\n\n      self._call(cmd, false).then(resolveCtx => {\n        // @ts-ignore - improve later.\n        const result = resolveCtx.reply.refresh;\n        self._refreshResponse(result);\n        // @ts-ignore - improve later.\n        if (resolveCtx.next) {\n          // @ts-ignore - improve later.\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        self._refreshError(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }).catch(function (e) {\n      self.emit('error', {\n        type: 'refreshToken',\n        error: {\n          code: errorCodes.clientRefreshToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n    });\n  }\n\n  private _refreshError(err: any) {\n    if (err.code < 100 || err.temporary === true) {\n      this.emit('error', {\n        type: 'refresh',\n        error: err\n      });\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n    } else {\n      this._disconnect(err.code, err.message, false);\n    }\n  }\n\n  private _getRefreshRetryDelay() {\n    return backoff(0, 5000, 10000);\n  }\n\n  private _refreshResponse(result: any) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._client = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _removeSubscription(sub: Subscription | null) {\n    if (sub === null) {\n      return;\n    }\n    delete this._subs[sub.channel];\n  }\n\n  protected _unsubscribe(sub: Subscription) {\n    if (!this._isConnected()) {\n      return;\n    }\n    const req = {\n      channel: sub.channel\n    };\n    const cmd = { unsubscribe: req };\n\n    const self = this;\n\n    this._call(cmd, false).then(resolveCtx => {\n      // @ts-ignore - improve later.\n      if (resolveCtx.next) {\n        // @ts-ignore - improve later.\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n      self._disconnect(connectingCodes.unsubscribeError, 'unsubscribe error', true);\n    });\n  }\n\n  private _getSub(channel: string) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  }\n\n  private _isServerSub(channel: string) {\n    return this._serverSubs[channel] !== undefined;\n  }\n\n  private _sendSubscribeCommands(optimistic: boolean, skipSending: boolean): any[] {\n    const commands: any[] = [];\n    for (const channel in this._subs) {\n      if (!this._subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = this._subs[channel];\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      if (sub._inflight === true) {\n        continue;\n      }\n      if (sub.state === SubscriptionState.Subscribing) {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        const cmd = sub._subscribe(optimistic, skipSending);\n        if (cmd) {\n          commands.push(cmd);\n        }\n      }\n    }\n    return commands;\n  }\n\n  private _connectResponse(result: any) {\n    this._transportWasOpen = true;\n    this._reconnectAttempts = 0;\n    this._refreshRequired = false;\n\n    if (this._isConnected()) {\n      return;\n    }\n\n    this._client = result.client;\n    this._setState(State.Connected);\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n\n    this._session = result.session;\n    this._node = result.node;\n\n    this.startBatching();\n    this._sendSubscribeCommands(false, false);\n    this.stopBatching();\n\n    const ctx: any = {\n      client: result.client,\n      transport: this._transport.subName()\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connected', ctx);\n\n    this._resolvePromises();\n\n    this._processServerSubs(result.subs || {});\n\n    if (result.ping && result.ping > 0) {\n      this._serverPing = result.ping * 1000;\n      this._sendPong = result.pong === true;\n      this._waitServerPing();\n    } else {\n      this._serverPing = 0;\n    }\n  }\n\n  private _processServerSubs(subs: Record<string, any>) {\n    for (const channel in subs) {\n      if (!subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = subs[channel];\n      this._serverSubs[channel] = {\n        'offset': sub.offset,\n        'epoch': sub.epoch,\n        'recoverable': sub.recoverable || false\n      };\n      const subCtx = this._getSubscribeContext(channel, sub);\n      this.emit('subscribed', subCtx);\n    }\n\n    for (const channel in subs) {\n      if (!subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = subs[channel];\n      if (sub.recovered) {\n        const pubs = sub.publications;\n        if (pubs && pubs.length > 0) {\n          for (const i in pubs) {\n            if (pubs.hasOwnProperty(i)) {\n              this._handlePublication(channel, pubs[i]);\n            }\n          }\n        }\n      }\n    }\n\n    for (const channel in this._serverSubs) {\n      if (!this._serverSubs.hasOwnProperty(channel)) {\n        continue;\n      }\n      if (!subs[channel]) {\n        this.emit('unsubscribed', { channel: channel });\n        delete this._serverSubs[channel];\n      }\n    }\n  }\n\n  private _clearRefreshTimeout() {\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n  }\n\n  private _clearReconnectTimeout() {\n    if (this._reconnectTimeout !== null) {\n      clearTimeout(this._reconnectTimeout);\n      this._reconnectTimeout = null;\n    }\n  }\n\n  private _clearServerPingTimeout() {\n    if (this._serverPingTimeout !== null) {\n      clearTimeout(this._serverPingTimeout);\n      this._serverPingTimeout = null;\n    }\n  }\n\n  private _waitServerPing() {\n    if (this._config.maxServerPingDelay === 0) {\n      return;\n    }\n    if (!this._isConnected()) {\n      return;\n    }\n    this._clearServerPingTimeout();\n    this._serverPingTimeout = setTimeout(() => {\n      if (!this._isConnected()) {\n        return;\n      }\n      this._disconnect(connectingCodes.noPing, 'no ping', true);\n    }, this._serverPing + this._config.maxServerPingDelay);\n  }\n\n  private _getSubscribeContext(channel: string, result: any): SubscribedContext {\n    const ctx: any = {\n      channel: channel,\n      positioned: false,\n      recoverable: false,\n      wasRecovering: false,\n      recovered: false\n    };\n    if (result.recovered) {\n      ctx.recovered = true;\n    }\n    if (result.positioned) {\n      ctx.positioned = true;\n    }\n    if (result.recoverable) {\n      ctx.recoverable = true;\n    }\n    if (result.was_recovering) {\n      ctx.wasRecovering = true;\n    }\n    let epoch = '';\n    if ('epoch' in result) {\n      epoch = result.epoch;\n    }\n    let offset = 0;\n    if ('offset' in result) {\n      offset = result.offset;\n    }\n    if (ctx.positioned || ctx.recoverable) {\n      ctx.streamPosition = {\n        'offset': offset,\n        'epoch': epoch\n      };\n    }\n    if (result.data) {\n      ctx.data = result.data;\n    }\n    return ctx;\n  }\n\n  private _handleReply(reply: any, next: any) {\n    const id = reply.id;\n    if (!(id in this._callbacks)) {\n      next();\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({ reply, next });\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        next();\n        return;\n      }\n      const error = reply.error;\n      errback({ error, next });\n    }\n  }\n\n  private _handleJoin(channel: string, join: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        const ctx = { channel: channel, info: this._getJoinLeaveContext(join.info) };\n        this.emit('join', ctx);\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handleJoin(join);\n  }\n\n  private _handleLeave(channel: string, leave: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        const ctx = { channel: channel, info: this._getJoinLeaveContext(leave.info) };\n        this.emit('leave', ctx);\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handleLeave(leave);\n  }\n\n  private _handleUnsubscribe(channel: string, unsubscribe: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        delete this._serverSubs[channel];\n        this.emit('unsubscribed', { channel: channel });\n      }\n      return;\n    }\n    if (unsubscribe.code < 2500) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      sub._setUnsubscribed(unsubscribe.code, unsubscribe.reason, false);\n    } else {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      sub._setSubscribing(unsubscribe.code, unsubscribe.reason);\n    }\n  }\n\n  private _handleSubscribe(channel: string, sub: any) {\n    this._serverSubs[channel] = {\n      'offset': sub.offset,\n      'epoch': sub.epoch,\n      'recoverable': sub.recoverable || false\n    };\n    this.emit('subscribed', this._getSubscribeContext(channel, sub));\n  }\n\n  private _handleDisconnect(disconnect: any) {\n    const code = disconnect.code;\n    let reconnect = true;\n    if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n      reconnect = false;\n    }\n    this._disconnect(code, disconnect.reason, reconnect);\n  }\n\n  private _getPublicationContext(channel: string, pub: any) {\n    const ctx: any = {\n      channel: channel,\n      data: pub.data\n    };\n    if (pub.offset) {\n      ctx.offset = pub.offset;\n    }\n    if (pub.info) {\n      ctx.info = this._getJoinLeaveContext(pub.info);\n    }\n    if (pub.tags) {\n      ctx.tags = pub.tags;\n    }\n    return ctx;\n  }\n\n  private _getJoinLeaveContext(clientInfo: any) {\n    const info: any = {\n      client: clientInfo.client,\n      user: clientInfo.user\n    };\n    if (clientInfo.conn_info) {\n      info.connInfo = clientInfo.conn_info;\n    }\n    if (clientInfo.chan_info) {\n      info.chanInfo = clientInfo.chan_info;\n    }\n    return info;\n  }\n\n  private _handlePublication(channel: string, pub: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        const ctx = this._getPublicationContext(channel, pub);\n        this.emit('publication', ctx);\n        if (pub.offset !== undefined) {\n          this._serverSubs[channel].offset = pub.offset;\n        }\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handlePublication(pub);\n  }\n\n  private _handleMessage(message: any) {\n    this.emit('message', { data: message.data });\n  }\n\n  private _handleServerPing(next: any) {\n    if (this._sendPong) {\n      const cmd = {};\n      this._transportSendCommands([cmd]);\n    }\n    next();\n  }\n\n  private _handlePush(data: any, next: any) {\n    const channel = data.channel;\n    if (data.pub) {\n      this._handlePublication(channel, data.pub);\n    } else if (data.message) {\n      this._handleMessage(data.message);\n    } else if (data.join) {\n      this._handleJoin(channel, data.join);\n    } else if (data.leave) {\n      this._handleLeave(channel, data.leave);\n    } else if (data.unsubscribe) {\n      this._handleUnsubscribe(channel, data.unsubscribe);\n    } else if (data.subscribe) {\n      this._handleSubscribe(channel, data.subscribe);\n    } else if (data.disconnect) {\n      this._handleDisconnect(data.disconnect);\n    }\n    next();\n  }\n\n  private _flush() {\n    const commands = this._commands.slice(0);\n    this._commands = [];\n    this._transportSendCommands(commands);\n  }\n\n  private _createErrorObject(code: number, message: string, temporary?: boolean) {\n    const errObject: any = {\n      code: code,\n      message: message\n    };\n    if (temporary) {\n      errObject.temporary = true;\n    }\n    return errObject;\n  }\n\n  private _registerCall(id: number, callback: any, errback: any) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback({ error: this._createErrorObject(errorCodes.timeout, 'timeout') });\n      }\n    }, this._config.timeout);\n  }\n\n  private _addCommand(command: any) {\n    if (this._batching) {\n      this._commands.push(command);\n    } else {\n      this._transportSendCommands([command]);\n    }\n  }\n\n  private _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  private _resolvePromises() {\n    for (const id in this._promises) {\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  }\n\n  private _rejectPromises(err: any) {\n    for (const id in this._promises) {\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  }\n}\n\nCentrifuge.SubscriptionState = SubscriptionState;\nCentrifuge.State = State\n", "/**\n * This file is the entrypoint of browser builds.\n */\nimport { Centrifuge } from './centrifuge'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(window as any).Centrifuge = Centrifuge\n"],
  "mappings": "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",
  "names": []
}
