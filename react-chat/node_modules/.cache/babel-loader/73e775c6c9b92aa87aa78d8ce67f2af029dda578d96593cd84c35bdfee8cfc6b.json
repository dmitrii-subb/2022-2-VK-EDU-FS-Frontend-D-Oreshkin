{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebtransportTransport = void 0;\n/** @internal */\nclass WebtransportTransport {\n  constructor(endpoint, options) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n    this._stream = null;\n    this._writer = null;\n    this._utf8decoder = new TextDecoder();\n    this._protocol = 'json';\n  }\n  name() {\n    return 'webtransport';\n  }\n  subName() {\n    return 'webtransport';\n  }\n  emulation() {\n    return false;\n  }\n  supported() {\n    return this.options.webtransport !== undefined && this.options.webtransport !== null;\n  }\n  initialize(protocol, callbacks) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let url;\n      if (globalThis && globalThis.document && globalThis.document.baseURI) {\n        // Handle case when endpoint is relative, like //example.com/connection/webtransport\n        url = new URL(this.endpoint, globalThis.document.baseURI);\n      } else {\n        url = new URL(this.endpoint);\n      }\n      if (protocol === 'protobuf') {\n        url.searchParams.append('cf_protocol', 'protobuf');\n      }\n      this._protocol = protocol;\n      const eventTarget = new EventTarget();\n      this._transport = new this.options.webtransport(url.toString());\n      this._transport.closed.then(() => {\n        callbacks.onClose({\n          code: 4,\n          reason: 'connection closed'\n        });\n      }).catch(() => {\n        callbacks.onClose({\n          code: 4,\n          reason: 'connection closed'\n        });\n      });\n      try {\n        yield this._transport.ready;\n      } catch (_a) {\n        this.close();\n        return;\n      }\n      let stream;\n      try {\n        stream = yield this._transport.createBidirectionalStream();\n      } catch (_b) {\n        this.close();\n        return;\n      }\n      this._stream = stream;\n      this._writer = this._stream.writable.getWriter();\n      eventTarget.addEventListener('close', () => {\n        callbacks.onClose({\n          code: 4,\n          reason: 'connection closed'\n        });\n      });\n      eventTarget.addEventListener('message', e => {\n        callbacks.onMessage(e.data);\n      });\n      this._startReading(eventTarget);\n      callbacks.onOpen();\n    });\n  }\n  _startReading(eventTarget) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const reader = this._stream.readable.getReader();\n      let jsonStreamBuf = '';\n      let jsonStreamPos = 0;\n      let protoStreamBuf = new Uint8Array();\n      try {\n        while (true) {\n          const {\n            done,\n            value\n          } = yield reader.read();\n          if (value.length > 0) {\n            if (this._protocol === 'json') {\n              jsonStreamBuf += this._utf8decoder.decode(value);\n              while (jsonStreamPos < jsonStreamBuf.length) {\n                if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                  const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                  eventTarget.dispatchEvent(new MessageEvent('message', {\n                    data: line\n                  }));\n                  jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                  jsonStreamPos = 0;\n                } else {\n                  ++jsonStreamPos;\n                }\n              }\n            } else {\n              const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n              mergedArray.set(protoStreamBuf);\n              mergedArray.set(value, protoStreamBuf.length);\n              protoStreamBuf = mergedArray;\n              while (true) {\n                const result = this.options.decoder.decodeReply(protoStreamBuf);\n                if (result.ok) {\n                  const data = protoStreamBuf.slice(0, result.pos);\n                  eventTarget.dispatchEvent(new MessageEvent('message', {\n                    data: data\n                  }));\n                  protoStreamBuf = protoStreamBuf.slice(result.pos);\n                  continue;\n                }\n                break;\n              }\n            }\n          }\n          if (done) {\n            break;\n          }\n        }\n      } catch (_a) {\n        eventTarget.dispatchEvent(new Event('close'));\n      }\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this._writer) {\n          yield this._writer.close();\n        }\n        this._transport.close();\n      } catch (e) {\n        // already closed.\n      }\n    });\n  }\n  send(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let binary;\n      if (this._protocol === 'json') {\n        // Need extra \\n since WT is non-frame protocol. \n        binary = new TextEncoder().encode(data + '\\n');\n      } else {\n        binary = data;\n      }\n      try {\n        yield this._writer.write(binary);\n      } catch (e) {\n        this.close();\n      }\n    });\n  }\n}\nexports.WebtransportTransport = WebtransportTransport;","map":{"version":3,"mappings":"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","names":["WebtransportTransport","constructor","endpoint","options","_transport","_stream","_writer","_utf8decoder","TextDecoder","_protocol","name","subName","emulation","supported","webtransport","undefined","initialize","protocol","callbacks","url","globalThis","document","baseURI","URL","searchParams","append","eventTarget","EventTarget","toString","closed","then","onClose","code","reason","catch","ready","close","stream","createBidirectionalStream","writable","getWriter","addEventListener","e","onMessage","data","_startReading","onOpen","reader","readable","getReader","jsonStreamBuf","jsonStreamPos","protoStreamBuf","Uint8Array","done","value","read","length","decode","line","substring","dispatchEvent","MessageEvent","mergedArray","set","result","decoder","decodeReply","ok","slice","pos","Event","send","binary","TextEncoder","encode","write","exports"],"sources":["../src/transport_webtransport.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}